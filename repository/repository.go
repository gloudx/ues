package repository

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/ipfs/go-cid"
	"github.com/ipld/go-ipld-prime/datamodel"
	cidlink "github.com/ipld/go-ipld-prime/linking/cid"
	"github.com/ipld/go-ipld-prime/node/basicnode"

	"ues/blockstore"
)

// Repository управляет контент-адресованной коллекцией записей, сгруппированных по имени коллекции.
// Репозиторий представляет собой версионированное хранилище данных, где каждая запись
// имеет уникальный идентификатор (rkey) в рамках своей коллекции и связана с CID содержимого.
// Использует MST (Merkle Search Tree) индекс для эффективного поиска и хранения записей,
// а также систему коммитов для отслеживания истории изменений.
//
// Основные компоненты:
//   - bs: блочное хранилище для сохранения IPLD узлов
//   - index: MST индекс для быстрого поиска записей по collection/rkey
//   - head: CID текущего коммита (HEAD репозитория)
//   - prev: CID предыдущего коммита (для цепочки истории)
//   - mu: мьютекс для обеспечения потокобезопасности
type Repository struct {
	bs    blockstore.Blockstore
	index *Index

	mu   sync.RWMutex
	head cid.Cid
	prev cid.Cid
}

// New создает новый пустой репозиторий с собственным индексом, поддерживаемым указанным blockstore.
// Репозиторий инициализируется в пустом состоянии без коммитов и записей.
//
// Параметры:
//   - bs: блочное хранилище, которое будет использоваться для сохранения всех данных репозитория
//
// Возвращает:
//   - *Repository: новый экземпляр репозитория, готовый к использованию
//
// Использование:
//
//	repo := New(blockstore)
//	// Репозиторий готов для добавления записей и создания коммитов
func New(bs blockstore.Blockstore) *Repository {
	return &Repository{bs: bs, index: NewIndex(bs)}
}

// LoadHead загружает состояние репозитория из существующего коммита по его CID.
// Этот метод восстанавливает полное состояние репозитория, включая индекс и внутренние указатели,
// из сохраненного ранее коммита. Используется для открытия существующего репозитория или
// восстановления состояния после перезапуска приложения.
//
// Параметры:
//   - ctx: контекст для отмены операции и передачи значений
//   - head: CID коммита, который должен стать новым HEAD репозитория.
//     Если передан cid.Undef, репозиторий будет сброшен в пустое состояние
//
// Возвращает:
//   - error: ошибка загрузки, если коммит не найден или имеет некорректную структуру
//
// Процесс загрузки:
// 1. Проверка валидности CID коммита
// 2. Загрузка узла коммита из blockstore
// 3. Парсинг структуры коммита для извлечения root и prev CID
// 4. Загрузка индекса из root CID
// 5. Обновление внутреннего состояния репозитория (head, prev)
//
// Потокобезопасность: метод использует мьютекс для защиты внутреннего состояния
func (r *Repository) LoadHead(ctx context.Context, head cid.Cid) error {
	// === Обработка случая пустого репозитория ===
	// Проверяем, передан ли валидный CID для загрузки
	// cid.Undef означает, что нужно сбросить репозиторий в пустое состояние
	if !head.Defined() {
		// Блокируем доступ к полям репозитория для записи
		// Это гарантирует атомарность операции сброса состояния
		r.mu.Lock()
		// Сбрасываем указатель на текущий HEAD коммит
		// cid.Undef означает отсутствие коммитов в репозитории
		r.head = cid.Undef
		// Сбрасываем указатель на предыдущий коммит
		// Для пустого репозитория предыдущего коммита не существует
		r.prev = cid.Undef
		// Освобождаем блокировку после обновления состояния
		r.mu.Unlock()
		// Загружаем пустой индекс в репозиторий
		// index.Load(cid.Undef) создает новый пустой индекс
		return r.index.Load(ctx, cid.Undef)
	}

	// === Загрузка узла коммита из blockstore ===
	// Получаем IPLD узел коммита по его CID из блочного хранилища
	// blockstore.GetNode десериализует данные блока в структуру узла
	node, err := r.bs.GetNode(ctx, head)
	if err != nil {
		// Если коммит не найден в blockstore или произошла ошибка десериализации,
		// возвращаем обернутую ошибку с контекстом операции
		return fmt.Errorf("load commit node: %w", err)
	}

	// === Парсинг структуры коммита ===
	// Извлекаем из узла коммита CID корневого узла индекса и CID предыдущего коммита
	// parseCommit разбирает структуру коммита и валидирует её корректность
	rootCID, prevCID, err := parseCommit(node)
	if err != nil {
		// Если структура коммита некорректна (отсутствуют обязательные поля,
		// неправильные типы данных и т.д.), прерываем загрузку
		return err
	}

	// === Загрузка индекса репозитория ===
	// Восстанавливаем состояние индекса из корневого CID, извлеченного из коммита
	// index.Load загружает MST-структуру индекса и все связанные данные
	if err := r.index.Load(ctx, rootCID); err != nil {
		// Если индекс не удается загрузить (поврежденные данные, отсутствующие блоки),
		// операция загрузки считается неуспешной
		return err
	}

	// === Обновление внутреннего состояния репозитория ===
	// Блокируем доступ к полям репозитория для записи
	// Это обеспечивает атомарность обновления состояния и потокобезопасность
	r.mu.Lock()
	// Устанавливаем новый HEAD репозитория на загруженный коммит
	// Теперь этот коммит считается текущим состоянием репозитория
	r.head = head
	// Сохраняем CID предыдущего коммита для поддержания цепочки коммитов
	// Это необходимо для создания следующих коммитов и отслеживания истории
	r.prev = prevCID
	// Освобождаем блокировку после успешного обновления состояния
	r.mu.Unlock()

	// Загрузка завершена успешно, репозиторий готов к работе
	// Возвращаем nil, сигнализируя об отсутствии ошибок
	return nil
}

// PutRecord сохраняет узел записи в блочном хранилище и индексирует его под указанным collection/rkey.
// Этот метод выполняет двухэтапную операцию: сначала сохраняет содержимое записи как IPLD узел,
// затем добавляет ссылку на этот узел в индекс репозитория для быстрого поиска.
//
// Параметры:
//   - ctx: контекст для отмены операции и передачи значений
//   - collection: имя коллекции, в которую добавляется запись (например, "posts", "users")
//   - rkey: уникальный ключ записи в рамках коллекции (record key)
//   - node: IPLD узел с данными записи для сохранения
//
// Возвращает:
//   - cid.Cid: CID сохраненного узла записи, который можно использовать для прямого доступа
//   - error: ошибка сохранения или индексирования
//
// Процесс выполнения:
// 1. Сериализация и сохранение узла в blockstore (получение CID)
// 2. Добавление mapping (collection, rkey) -> CID в индекс
// 3. Возврат CID для дальнейшего использования
//
// Важно: изменения индекса остаются в памяти до вызова Commit()
func (r *Repository) PutRecord(ctx context.Context, collection, rkey string, node datamodel.Node) (cid.Cid, error) {
	// === Сохранение узла записи в blockstore ===
	// Сериализуем IPLD узел и сохраняем его в блочном хранилище
	// blockstore автоматически вычисляет CID на основе содержимого узла
	valueCID, err := r.bs.PutNode(ctx, node)
	if err != nil {
		// Если не удается сохранить узел (проблемы с сериализацией, недоступность хранилища),
		// возвращаем неопределенный CID и обернутую ошибку с контекстом
		return cid.Undef, fmt.Errorf("store record node: %w", err)
	}

	// === Индексирование записи ===
	// Добавляем mapping от (collection, rkey) к CID в индекс репозитория
	// Это позволяет быстро находить записи по их логическому адресу
	// index.Put может изменить структуру MST индекса для поддержания упорядоченности
	if _, err := r.index.Put(ctx, collection, rkey, valueCID); err != nil {
		// Если индексирование не удалось (например, проблемы с обновлением MST),
		// возвращаем ошибку. Узел уже сохранен в blockstore, но не проиндексирован
		return cid.Undef, err
	}

	// Успешно сохранили и проиндексировали запись
	// Возвращаем CID для возможности прямого доступа к содержимому
	return valueCID, nil
}

// DeleteRecord удаляет mapping записи из индекса репозитория.
// Этот метод удаляет связь между логическим адресом (collection, rkey) и CID содержимого
// из индекса репозитория. Важно отметить, что сами данные в blockstore не удаляются -
// удаляется только ссылка на них из индекса.
//
// Параметры:
//   - ctx: контекст для отмены операции и передачи значений
//   - collection: имя коллекции, из которой удаляется запись
//   - rkey: ключ записи для удаления из указанной коллекции
//
// Возвращает:
//   - bool: true, если запись была найдена и удалена; false, если запись не существовала
//   - error: ошибка удаления, если операция не удалась
//
// Поведение:
// - Если запись существует: удаляет её из индекса и возвращает true
// - Если запись не существует: не выполняет действий и возвращает false
// - Изменения индекса остаются в памяти до вызова Commit()
//
// Важно: данные в blockstore остаются доступными по CID даже после удаления из индекса
func (r *Repository) DeleteRecord(ctx context.Context, collection, rkey string) (bool, error) {
	// Вызываем метод Delete индекса для удаления mapping (collection, rkey) -> CID
	// index.Delete возвращает три значения:
	// 1. старый CID (который мы игнорируем через _)
	// 2. флаг removed - был ли элемент действительно удален
	// 3. ошибка операции
	_, removed, err := r.index.Delete(ctx, collection, rkey)
	if err != nil {
		// Если произошла ошибка при удалении (например, проблемы с обновлением MST),
		// возвращаем false и ошибку операции
		return false, err
	}

	// Возвращаем флаг removed, который указывает:
	// - true: запись существовала и была успешно удалена
	// - false: запись не существовала в индексе (операция без изменений)
	return removed, nil
}

// GetRecordCID разрешает CID содержимого для записи collection/rkey из индекса.
// Этот метод выполняет поиск в индексе репозитория для получения CID, связанного
// с указанным логическим адресом записи. CID можно затем использовать для
// прямого получения содержимого записи из blockstore.
//
// Параметры:
//   - ctx: контекст для отмены операции и передачи значений
//   - collection: имя коллекции для поиска записи
//   - rkey: ключ записи в указанной коллекции
//
// Возвращает:
//   - cid.Cid: CID содержимого записи (если найдена) или cid.Undef (если не найдена)
//   - bool: true, если запись найдена в индексе; false, если запись отсутствует
//   - error: ошибка поиска, если операция не удалась
//
// Использование результатов:
//
//	cid, found, err := repo.GetRecordCID(ctx, "posts", "post123")
//	if found {
//	    node, err := blockstore.GetNode(ctx, cid)
//	    // работа с содержимым записи
//	}
//
// Потокобезопасность: метод только читает из индекса, поэтому безопасен для параллельного использования
func (r *Repository) GetRecordCID(ctx context.Context, collection, rkey string) (cid.Cid, bool, error) {
	// Делегируем поиск индексу репозитория
	// index.Get выполняет поиск в MST структуре по ключу (collection, rkey)
	// и возвращает связанный с ним CID, если запись существует
	return r.index.Get(ctx, collection, rkey)
}

// ListCollection возвращает упорядоченные записи индекса для указанной коллекции.
// Этот метод извлекает все записи из указанной коллекции и возвращает их CID в том порядке,
// в котором они хранятся в MST индексе (лексикографический порядок по rkey).
//
// Параметры:
//   - ctx: контекст для отмены операции и передачи значений
//   - collection: имя коллекции для получения списка записей
//
// Возвращает:
//   - []cid.Cid: срез CID всех записей в коллекции, упорядоченный по rkey
//   - error: ошибка получения списка, если операция не удалась
//
// Особенности:
// - Записи возвращаются в лексикографическом порядке их rkey
// - Пустая коллекция возвращает пустой срез (не nil)
// - MST гарантирует эффективное получение упорядоченного списка
//
// Использование:
//
//	cids, err := repo.ListCollection(ctx, "posts")
//	for _, cid := range cids {
//	    node, err := blockstore.GetNode(ctx, cid)
//	    // обработка каждой записи
//	}
//
// Производительность: O(n) где n - количество записей в коллекции
func (r *Repository) ListCollection(ctx context.Context, collection string) ([]cid.Cid, error) {
	// Получаем полный список записей коллекции из индекса
	// index.ListCollection возвращает срез Entry структур, содержащих rkey и CID
	entries, err := r.index.ListCollection(ctx, collection)
	if err != nil {
		// Если произошла ошибка при обходе MST или чтении данных,
		// возвращаем nil срез и ошибку
		return nil, err
	}

	// Создаем выходной срез с предварительно выделенной памятью
	// Это избегает множественных реаллокаций при добавлении элементов
	out := make([]cid.Cid, len(entries))

	// Извлекаем только CID из каждой записи индекса
	// Entry содержит как rkey, так и CID, но нам нужны только CID
	for i, entry := range entries {
		out[i] = entry.Value
	}

	// Возвращаем срез CID в том же порядке, что и записи в индексе
	return out, nil
}

// Commit сохраняет текущее состояние индекса как новый коммит и возвращает его CID.
// Этот метод создает снимок текущего состояния репозитория, формируя новый коммит
// в цепочке истории изменений. Коммит содержит ссылку на корневой узел индекса,
// ссылку на предыдущий коммит и временную метку создания.
//
// Параметры:
//   - ctx: контекст для отмены операции и передачи значений
//
// Возвращает:
//   - cid.Cid: CID созданного коммита, который становится новым HEAD репозитория
//   - error: ошибка создания коммита, если операция не удалась
//
// Процесс создания коммита:
// 1. Сохранение текущего HEAD как предыдущего коммита
// 2. Получение корневого CID текущего состояния индекса
// 3. Создание узла коммита с root, prev и timestamp
// 4. Сохранение узла коммита в blockstore
// 5. Обновление внутреннего состояния (head, prev)
//
// Потокобезопасность: использует RLock для чтения и Lock для записи состояния
// Атомарность: все изменения применяются только после успешного сохранения коммита
func (r *Repository) Commit(ctx context.Context) (cid.Cid, error) {
	// === Чтение текущего состояния репозитория ===
	// Используем RLock для безопасного чтения текущего HEAD
	// Несколько горутин могут одновременно читать head, но запись блокируется
	r.mu.RLock()
	// Сохраняем текущий HEAD как предыдущий коммит для нового коммита
	// Это создает связь в цепочке коммитов: новый -> текущий -> предыдущий -> ...
	prev := r.head
	r.mu.RUnlock()

	// === Создание узла коммита ===
	// Строим IPLD узел коммита, содержащий:
	// - root: CID корневого узла текущего индекса
	// - prev: CID предыдущего коммита (или cid.Undef для первого коммита)
	// - timestamp: текущее время создания коммита
	commitNode, err := buildCommitNode(r.index.Root(), prev, time.Now())
	if err != nil {
		// Если не удается создать структуру коммита (ошибка сериализации IPLD),
		// возвращаем неопределенный CID и ошибку
		return cid.Undef, err
	}

	// === Сохранение коммита в blockstore ===
	// Сериализуем и сохраняем узел коммита в блочном хранилище
	// blockstore автоматически вычисляет CID коммита на основе его содержимого
	headCID, err := r.bs.PutNode(ctx, commitNode)
	if err != nil {
		// Если не удается сохранить коммит (проблемы с blockstore),
		// возвращаем ошибку с контекстом операции
		return cid.Undef, fmt.Errorf("store commit node: %w", err)
	}

	// === Атомарное обновление состояния репозитория ===
	// Блокируем репозиторий для записи для атомарного обновления состояния
	r.mu.Lock()
	// Обновляем prev на предыдущий HEAD (создание цепочки)
	// Это значение будет использовано при создании следующего коммита
	r.prev = prev
	// Устанавливаем новый HEAD репозитория на только что созданный коммит
	// Теперь репозиторий указывает на новое состояние
	r.head = headCID
	r.mu.Unlock()

	// Коммит успешно создан и сохранен
	// Возвращаем CID нового коммита для использования клиентским кодом
	return headCID, nil
}

// buildCommitNode создает IPLD узел, представляющий коммит в репозитории.
// Коммит содержит ссылку на корневой узел текущего состояния репозитория,
// ссылку на предыдущий коммит (для создания цепочки коммитов) и временную метку.
//
// Параметры:
//   - root: CID корневого узла индекса репозитория на момент коммита
//   - prev: CID предыдущего коммита в цепочке (может быть неопределенным для первого коммита)
//   - ts: временная метка создания коммита
//
// Возвращает:
//   - datamodel.Node: IPLD узел, представляющий структуру коммита
//   - error: ошибка при создании узла
//
// Структура коммита в виде карты:
//
//	{
//	  "root": <ссылка на корневой CID>,
//	  "prev": <ссылка на предыдущий коммит или null>,
//	  "timestamp": <Unix временная метка в секундах>
//	}
func buildCommitNode(root cid.Cid, prev cid.Cid, ts time.Time) (datamodel.Node, error) {
	// Создаем билдер для построения IPLD узла типа "карта" (map)
	// Используем базовый прототип карты из библиотеки basicnode
	builder := basicnode.Prototype.Map.NewBuilder()

	// Начинаем сборку карты с 3 элементами: root, prev, timestamp
	// Количество элементов указывается заранее для оптимизации памяти
	ma, err := builder.BeginMap(3)
	if err != nil {
		return nil, err
	}

	// === Добавляем поле "root" ===
	// Создаем новую запись в карте с ключом "root"
	entry, err := ma.AssembleEntry("root")
	if err != nil {
		return nil, err
	}
	// Проверяем, определен ли корневой CID
	if root.Defined() {
		// Если корень определен, создаем ссылку на него
		if err := entry.AssignLink(cidlink.Link{Cid: root}); err != nil {
			return nil, err
		}
	} else {
		// Если корень не определен (пустой репозиторий), устанавливаем null
		if err := entry.AssignNull(); err != nil {
			return nil, err
		}
	}

	// === Добавляем поле "prev" ===
	// Создаем запись для ссылки на предыдущий коммит
	entry, err = ma.AssembleEntry("prev")
	if err != nil {
		return nil, err
	}
	// Проверяем, определен ли предыдущий коммит
	if prev.Defined() {
		// Если есть предыдущий коммит, сохраняем ссылку на него
		// Это создает цепочку коммитов для отслеживания истории изменений
		if err := entry.AssignLink(cidlink.Link{Cid: prev}); err != nil {
			return nil, err
		}
	} else {
		// Если предыдущего коммита нет (первый коммит в репозитории),
		// устанавливаем значение null
		if err := entry.AssignNull(); err != nil {
			return nil, err
		}
	}

	// === Добавляем поле "timestamp" ===
	// Создаем запись для временной метки коммита
	entry, err = ma.AssembleEntry("timestamp")
	if err != nil {
		return nil, err
	}
	// Сохраняем время в формате Unix timestamp (секунды с 1 января 1970 года)
	// Это стандартный способ представления времени в компьютерных системах
	if err := entry.AssignInt(ts.Unix()); err != nil {
		return nil, err
	}

	// Завершаем сборку карты - проверяем, что все поля добавлены корректно
	if err := ma.Finish(); err != nil {
		return nil, err
	}

	// Строим финальный IPLD узел и возвращаем его
	// Этот узел может быть сериализован и сохранен в blockstore
	return builder.Build(), nil
}

// parseCommit разбирает IPLD узел коммита и извлекает из него корневой CID и CID предыдущего коммита.
// Эта функция является обратной к buildCommitNode - она читает структуру коммита,
// созданную ранее, и извлекает из неё необходимые данные для восстановления состояния репозитория.
//
// Параметры:
//   - node: IPLD узел, представляющий коммит (должен быть картой с полями "root" и "prev")
//
// Возвращает:
//   - cid.Cid: CID корневого узла индекса репозитория на момент этого коммита
//   - cid.Cid: CID предыдущего коммита в цепочке (или cid.Undef если это первый коммит)
//   - error: ошибка парсинга, если структура коммита некорректна
//
// Ожидаемая структура входного узла:
//
//	{
//	  "root": <ссылка на корневой CID>,
//	  "prev": <ссылка на предыдущий коммит или null>,
//	  "timestamp": <Unix временная метка в секундах>
//	}
func parseCommit(node datamodel.Node) (cid.Cid, cid.Cid, error) {
	// === Извлечение поля "root" ===
	// Ищем в узле коммита поле с ключом "root"
	// Это поле должно содержать ссылку на корневой узел индекса репозитория
	rootNode, err := node.LookupByString("root")
	if err != nil {
		// Если поле "root" отсутствует, коммит считается некорректным
		// Возвращаем неопределенные CID и описательную ошибку
		return cid.Undef, cid.Undef, fmt.Errorf("commit missing root: %w", err)
	}

	// Инициализируем CID корня как неопределенный
	rootCID := cid.Undef

	// Проверяем, не является ли поле "root" значением null
	// null означает пустой репозиторий без коллекций
	if !rootNode.IsNull() {
		// Преобразуем найденный узел в ссылку (Link)
		// В IPLD ссылки представляют CID-указатели на другие узлы
		rootLink, err := rootNode.AsLink()
		if err != nil {
			// Если узел не является ссылкой, структура коммита нарушена
			return cid.Undef, cid.Undef, fmt.Errorf("commit root is not a link: %w", err)
		}

		// Приводим общий тип Link к конкретному типу cidlink.Link
		// cidlink.Link - это обертка IPLD для CID, содержащая поле Cid
		rl, ok := rootLink.(cidlink.Link)
		if !ok {
			// Если приведение типа не удалось, значит ссылка имеет неожиданный тип
			return cid.Undef, cid.Undef, fmt.Errorf("commit root link type unexpected")
		}
		rootCID = rl.Cid
	}

	// === Извлечение поля "prev" ===
	// Ищем поле "prev", которое содержит ссылку на предыдущий коммит
	// Это поле может быть null для первого коммита в цепочке
	prevNode, err := node.LookupByString("prev")
	if err != nil {
		// Если поле "prev" отсутствует, коммит считается некорректным
		return cid.Undef, cid.Undef, fmt.Errorf("commit missing prev: %w", err)
	}

	// Инициализируем CID предыдущего коммита как неопределенный
	// Это значение останется, если prev равно null (первый коммит)
	prevCID := cid.Undef

	// Проверяем, не является ли поле "prev" значением null
	// null означает, что это первый коммит в репозитории без предшественников
	if !prevNode.IsNull() {
		// Если prev не null, значит есть предыдущий коммит
		// Преобразуем узел в ссылку для извлечения CID
		prevLink, err := prevNode.AsLink()
		if err != nil {
			// Если prev не null, но и не ссылка - ошибка структуры
			return cid.Undef, cid.Undef, fmt.Errorf("commit prev is not a link: %w", err)
		}

		// Приводим ссылку к типу cidlink.Link для доступа к CID
		pl, ok := prevLink.(cidlink.Link)
		if !ok {
			// Если тип ссылки неожиданный, сообщаем об ошибке
			return cid.Undef, cid.Undef, fmt.Errorf("commit prev link type unexpected")
		}

		// Извлекаем CID предыдущего коммита из ссылки
		// Теперь prevCID содержит валидный CID вместо Undef
		prevCID = pl.Cid
	}

	// Возвращаем успешно извлеченные CID:
	// - rootCID: CID корневого узла индекса на момент коммита (или Undef для пустого репозитория)
	// - prevCID: CID предыдущего коммита (или Undef для первого коммита)
	// - nil: отсутствие ошибок при парсинге
	return rootCID, prevCID, nil
}
