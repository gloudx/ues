// Package repository содержит lexicon систему схем и валидации данных
//
// НАЗНАЧЕНИЕ:
// Lexicon система обеспечивает типобезопасность, валидацию и эволюцию схем данных
// в UES. Интегрируется с IPLD schema для максимальной совместимости и производительности.
//
// КЛЮЧЕВЫЕ ВОЗМОЖНОСТИ:
// - IPLD Schema интеграция для типобезопасности
// - Версионирование схем с backward compatibility
// - Автоматическая валидация записей
// - Schema-aware индексирование
// - Evolution support для изменения схем
//
// АРХИТЕКТУРНАЯ РОЛЬ:
// Lexicon система является частью Repository Layer (уровень 3) и обеспечивает
// контрактный слой между приложениями и данными, гарантируя корректность
// структур данных на всех этапах их жизненного цикла.
package repository

import (
	"fmt"
	"time"

	"github.com/ipfs/go-cid"
	"github.com/ipld/go-ipld-prime/schema"
)

// === CORE TYPES ===
// Базовые типы для работы с лексиконами в Repository Layer

// LexiconDefinition представляет определение лексикона данных
//
// КОНЦЕПЦИЯ:
// Лексикон в UES - это типизированная схема данных, определяющая структуру,
// валидацию и индексирование для конкретного типа записей. Каждый лексикон
// имеет версионирование для обеспечения эволюции схем с обратной совместимостью.
//
// ЖИЗНЕННЫЙ ЦИКЛ ЛЕКСИКОНА:
// 1. DRAFT - разработка и тестирование схемы
// 2. ACTIVE - готов к продакшн использованию
// 3. DEPRECATED - устарел, но еще поддерживается
// 4. ARCHIVED - не используется, хранится для истории
//
// ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ:
// - Схемы для социальных постов (title, content, metadata)
// - Профили пользователей (name, bio, avatar, settings)
// - Комментарии (text, author, timestamp, thread_id)
// - Файловые метаданные (filename, size, mime_type, checksum)
//
// ИНТЕГРАЦИЯ С IPLD:
// Каждый лексикон компилируется в IPLD TypeSystem для обеспечения
// типобезопасности на уровне протокола и совместимости с экосистемой IPFS.
type LexiconDefinition struct {
	// === ОСНОВНАЯ ИНФОРМАЦИЯ ===
	// Базовая идентификационная информация лексикона

	ID          string        `json:"id"`          // Уникальный идентификатор лексикона (nsid формат: domain.tld.collection.record)
	Version     SchemaVersion `json:"version"`     // Версия схемы (семантическое версионирование Major.Minor.Patch)
	Name        string        `json:"name"`        // Человекочитаемое имя лексикона для UI и документации
	Description string        `json:"description"` // Подробное описание назначения и области применения схемы
	Namespace   string        `json:"namespace"`   // Пространство имен для группировки связанных лексиконов
	Status      SchemaStatus  `json:"status"`      // Текущий статус в жизненном цикле (draft/active/deprecated/archived)

	// === IPLD SCHEMA INTEGRATION ===
	// Интеграция с IPLD schema system для типобезопасности

	Schema *schema.TypeSystem `json:"-"` // Скомпилированная IPLD схема (исключается из JSON сериализации для производительности)

	// === МЕТАДАННЫЕ РАЗРАБОТКИ ===
	// Информация о создании, авторстве и лицензировании лексикона

	Author       string                 `json:"author"`             // Автор или организация, создавшая лексикон
	License      string                 `json:"license"`            // Лицензия использования (MIT, Apache-2.0, proprietary, etc.)
	Keywords     []string               `json:"keywords"`           // Ключевые слова для поиска и категоризации лексикона
	Metadata     map[string]interface{} `json:"metadata,omitempty"` // Расширяемые метаданные для хранения дополнительной информации
	CreatedAt    time.Time              `json:"created_at"`         // Временная метка первоначального создания лексикона
	UpdatedAt    time.Time              `json:"updated_at"`         // Временная метка последнего изменения содержимого лексикона
	RegisteredAt time.Time              `json:"registered_at"`      // Временная метка регистрации в реестре лексиконов
	StorageCID   cid.Cid                `json:"storage_cid"`        // Content Identifier для ссылки на данные лексикона в blockstore

	// === ЗАВИСИМОСТИ И СВЯЗИ ===
	// Определение связей с другими лексиконами для построения композитных схем
	Dependencies []LexiconDependency `json:"dependencies,omitempty"` // Список зависимостей от других лексиконов с указанием версий

	// === ВАЛИДАЦИЯ И ИНДЕКСИРОВАНИЕ ===
	// Определения для автоматической валидации данных и создания индексов
	Indexes    []IndexDefinition     `json:"indexes,omitempty"`    // Спецификации индексов для оптимизации запросов к данным этого типа
	Validators []ValidatorDefinition `json:"validators,omitempty"` // Кастомные валидаторы для бизнес-логики проверки данных

	// === СОВМЕСТИМОСТЬ И ЭВОЛЮЦИЯ ===
	// Механизмы для обеспечения совместимости при эволюции схем
	CompatibleWith []SchemaVersion `json:"compatible_with,omitempty"` // Список версий схем, с которыми данная версия совместима
	DeprecatedAt   *time.Time      `json:"deprecated_at,omitempty"`   // Временная метка объявления схемы устаревшей (nil если активна)
	Migrations     []Migration     `json:"migrations,omitempty"`      // Набор миграций для перехода между версиями схемы
}

// LexiconDependency представляет зависимость от другого лексикона
//
// НАЗНАЧЕНИЕ:
// Позволяет создавать композитные схемы, ссылающиеся на другие лексиконы.
// Обеспечивает контроль версий зависимостей и возможность опциональных связей.
//
// ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ:
// - Пост может зависеть от лексикона User для поля author
// - Комментарий зависит от Post для связи с родительским объектом
// - Профиль может опционально зависеть от лексикона Avatar
//
// РАЗРЕШЕНИЕ ЗАВИСИМОСТЕЙ:
// Registry автоматически проверяет и загружает все зависимости при регистрации
// лексикона, обеспечивая целостность схем и предотвращая циклические зависимости.
type LexiconDependency struct {
	ID       string        `json:"id"`       // Уникальный идентификатор зависимого лексикона (nsid формат)
	Version  SchemaVersion `json:"version"`  // Требуемая версия зависимости (может использовать семантические ограничения)
	Optional bool          `json:"optional"` // Флаг опциональности: true = схема может работать без этой зависимости
}

// SchemaStatus определяет статус лексикона в жизненном цикле
//
// НАЗНАЧЕНИЕ:
// Управление жизненным циклом лексиконов от разработки до архивирования.
// Позволяет контролировать использование схем в продакшене и планировать их эволюцию.
//
// ПЕРЕХОДЫ СТАТУСОВ:
// draft -> active: после завершения разработки и тестирования
// active -> deprecated: когда появляется новая версия или схема устаревает
// deprecated -> archived: когда схема больше не поддерживается
//
// ПРАВИЛА ИСПОЛЬЗОВАНИЯ:
// - DRAFT: только для разработки и тестирования
// - ACTIVE: разрешено использование в продакшене
// - DEPRECATED: работает, но выдает предупреждения
// - ARCHIVED: блокируется создание новых записей
type SchemaStatus string

const (
	SchemaStatusDraft      SchemaStatus = "draft"      // Черновик - схема в разработке, не готова для продакшена
	SchemaStatusActive     SchemaStatus = "active"     // Активная - готова к полноценному использованию в продакшене
	SchemaStatusDeprecated SchemaStatus = "deprecated" // Устаревшая - работает, но не рекомендуется для новых проектов
	SchemaStatusArchived   SchemaStatus = "archived"   // Архивная - не используется, сохранена только для совместимости
)

// SchemaVersion представляет версию схемы (семантическое версионирование)
//
// СЕМАНТИЧЕСКОЕ ВЕРСИОНИРОВАНИЕ (SemVer):
// - MAJOR: несовместимые изменения API (breaking changes)
// - MINOR: обратно совместимые новые функции (backward compatible)
// - PATCH: обратно совместимые исправления ошибок
//
// ПРИМЕРЫ ИЗМЕНЕНИЙ:
// - PATCH (1.0.0 -> 1.0.1): исправление валидации, улучшение документации
// - MINOR (1.0.1 -> 1.1.0): добавление необязательного поля, новый индекс
// - MAJOR (1.1.0 -> 2.0.0): удаление поля, изменение типа данных, новая структура
//
// СОВМЕСТИМОСТЬ:
// Приложения могут безопасно использовать новые PATCH и MINOR версии,
// но требуют обновления для MAJOR версий.
type SchemaVersion struct {
	Major int `json:"major"` // Мажорная версия - несовместимые изменения
	Minor int `json:"minor"` // Минорная версия - обратно совместимые дополнения
	Patch int `json:"patch"` // Патч версия - исправления без изменения API
}

// String возвращает строковое представление версии в формате "major.minor.patch"
//
// ИСПОЛЬЗОВАНИЕ:
// Удобно для логирования, отображения в UI и сравнения версий в текстовом виде.
// Соответствует стандартному формату семантического версионирования.
func (v SchemaVersion) String() string {
	return fmt.Sprintf("%d.%d.%d", v.Major, v.Minor, v.Patch)
}

// Equal проверяет равенство двух версий схемы
//
// ПРИМЕНЕНИЕ:
// Используется для точного сравнения версий при поиске лексиконов,
// проверке совместимости и валидации зависимостей.
//
// ЛОГИКА:
// Версии считаются равными только если все три компонента (major, minor, patch)
// идентичны. Это строгое сравнение, не учитывающее семантическую совместимость.
func (v SchemaVersion) Equal(other SchemaVersion) bool {
	return v.Major == other.Major && v.Minor == other.Minor && v.Patch == other.Patch
}

// Compare сравнивает версии по семантическому приоритету
//
// ВОЗВРАЩАЕМЫЕ ЗНАЧЕНИЯ:
// -1: текущая версия меньше (старше) переданной
//
//	0: версии идентичны
//	1: текущая версия больше (новее) переданной
//
// АЛГОРИТМ СРАВНЕНИЯ:
// 1. Сначала сравнивается major версия (приоритет)
// 2. При равенстве major сравнивается minor версия
// 3. При равенстве major и minor сравнивается patch версия
//
// ИСПОЛЬЗОВАНИЕ:
// Применяется для сортировки версий, определения порядка миграций
// и автоматического выбора наиболее подходящей версии схемы.
func (v SchemaVersion) Compare(other SchemaVersion) int {
	if v.Major != other.Major {
		if v.Major < other.Major {
			return -1
		}
		return 1
	}
	if v.Minor != other.Minor {
		if v.Minor < other.Minor {
			return -1
		}
		return 1
	}
	if v.Patch != other.Patch {
		if v.Patch < other.Patch {
			return -1
		}
		return 1
	}
	return 0
}

// LexiconID представляет уникальный идентификатор лексикона
//
// ФОРМАТ NSID (Namespaced Identifier):
// Следует спецификации AT Protocol для обеспечения глобальной уникальности:
// domain.tld.collection.record
//
// КОМПОНЕНТЫ:
// - domain.tld: доменное имя владельца схемы (гарантирует уникальность)
// - collection: тип коллекции или категория данных
// - record: конкретный тип записи в коллекции
//
// ПРИМЕРЫ ИСПОЛЬЗОВАНИЯ:
// - app.bsky.feed.post - посты в социальной ленте Bluesky
// - com.example.blog.article - статьи блога компании Example
// - org.w3.activitypub.note - заметки по стандарту ActivityPub
// - edu.university.student.profile - профили студентов университета
//
// ПРЕИМУЩЕСТВА NSID:
// - Глобальная уникальность без центрального реестра
// - Иерархическая структура для организации схем
// - Совместимость с федеративными протоколами
// - Простота понимания и запоминания
type LexiconID string

// RecordID представляет уникальный идентификатор записи в коллекции
//
// ФОРМАТ И ГЕНЕРАЦИЯ:
// RecordID может быть задан пользователем или сгенерирован автоматически.
// Поддерживаемые форматы зависят от конфигурации Repository.
//
// ТИПЫ ИДЕНТИФИКАТОРОВ:
// - UUID: универсально уникальные идентификаторы (recommend для автогенерации)
// - Timestamp-based: базируются на времени создания (TID, ULID)
// - Meaningful slugs: человекочитаемые идентификаторы (url-friendly)
// - Sequential: последовательные числовые идентификаторы
//
// ПРИМЕРЫ:
// - "550e8400-e29b-41d4-a716-446655440000" (UUID)
// - "01H4VKJN2P8K3G9M7F6D2Q1W8E" (ULID)
// - "getting-started-with-ues" (slug)
// - "post-2024-09-20-001" (timestamp + sequence)
//
// ТРЕБОВАНИЯ:
// - Уникальность в рамках коллекции
// - URL-safe символы (только ASCII, без пробелов)
// - Длина не более 256 символов
type RecordID string

// IndexDefinition определяет индекс для быстрого поиска по полям схемы
//
// НАЗНАЧЕНИЕ:
// Автоматическое создание оптимизированных индексов базы данных на основе
// определений в лексиконе. Обеспечивает высокую производительность запросов
// без необходимости ручной настройки индексов.
//
// СТРАТЕГИИ ИНДЕКСИРОВАНИЯ:
// - Single field: индекс по одному полю для простых фильтров
// - Composite: многопольные индексы для сложных запросов
// - Unique: индексы с ограничением уникальности
// - Sparse: индексы только для непустых значений (экономия места)
// - Full-text: специализированные индексы для текстового поиска
//
// АВТОМАТИЧЕСКАЯ ОПТИМИЗАЦИЯ:
// LexiconIndexer анализирует паттерны запросов и автоматически создает
// наиболее эффективные индексы для каждого типа данных в схеме.
//
// ТИПЫ ИНДЕКСОВ:
// - btree: упорядоченный B-Tree индекс для диапазонных запросов и сортировки
// - hash: хеш-индекс для быстрого точного поиска по равенству
// - fts: полнотекстовый поиск через SQLite FTS5 с поддержкой языков
// - geo: геопространственный индекс для координат (планируется)
// - composite: составной индекс по нескольким полям для сложных фильтров
type IndexDefinition struct {
	Name     string                 `json:"name"`               // Уникальное имя индекса в рамках лексикона (используется для DDL операций)
	Fields   []string               `json:"fields"`             // Список полей схемы для включения в индекс (порядок важен для composite)
	Type     IndexType              `json:"type"`               // Тип индекса (определяет алгоритм и возможности поиска)
	Unique   bool                   `json:"unique"`             // Ограничение уникальности значений (создает UNIQUE INDEX)
	Sparse   bool                   `json:"sparse"`             // Разреженный индекс - игнорирует NULL значения для экономии места
	Metadata map[string]interface{} `json:"metadata,omitempty"` // Расширяемые параметры индекса (конфигурация FTS, веса полей и т.д.)
}

// IndexType определяет тип и алгоритм индексирования
//
// ВЫБОР ТИПА ИНДЕКСА:
// Правильный выбор типа критически важен для производительности запросов.
// Каждый тип оптимизирован для определенных паттернов доступа к данным.
//
// РЕКОМЕНДАЦИИ ПО ИСПОЛЬЗОВАНИЮ:
// - btree: для числовых данных, дат, сортировки, диапазонных запросов
// - hash: для строковых ID, enum значений, точного поиска
// - fts: для текстового контента, описаний, комментариев
// - geo: для координат, географических данных (будущая функциональность)
// - composite: для запросов по нескольким полям одновременно
type IndexType string

const (
	IndexTypeBTree     IndexType = "btree"     // B-Tree индекс - оптимален для упорядоченных данных и диапазонных запросов
	IndexTypeHash      IndexType = "hash"      // Хеш-индекс - быстрый поиск по точному совпадению значения
	IndexTypeFTS       IndexType = "fts"       // Full-Text Search - полнотекстовый поиск с токенизацией и ранжированием
	IndexTypeGeo       IndexType = "geo"       // Геопространственный индекс для координат и пространственных запросов
	IndexTypeComposite IndexType = "composite" // Составной индекс
)

// ValidatorDefinition определяет правила валидации данных для схемы лексикона
//
// АРХИТЕКТУРНАЯ РОЛЬ:
// Валидаторы обеспечивают целостность данных на уровне схемы до их сохранения
// в хранилище. Они работают как промежуточный слой между входящими данными
// и Repository Layer, гарантируя соответствие структуре и ограничениям лексикона.
//
// ТИПЫ ВАЛИДАЦИИ:
// 1. Структурная - проверка наличия обязательных полей, типов данных
// 2. Семантическая - проверка бизнес-правил, диапазонов значений
// 3. Ссылочная - проверка внешних ключей и зависимостей между записями
// 4. Пользовательская - кастомные функции валидации через ValidatorFunc
//
// ИНТЕГРАЦИЯ С IPLD:
// Работает совместно с IPLD схемами для обеспечения типобезопасности
// на уровне протокола и бизнес-логики приложения одновременно.
//
// ПРОИЗВОДИТЕЛЬНОСТЬ:
// Валидаторы выполняются в порядке определения. Быстрые проверки
// (required, type) следует размещать в начале для раннего отклонения.
//
// ПРИМЕРЫ КОНФИГУРАЦИИ:
// - regex: {"pattern": "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$"}
// - range: {"min": 0, "max": 100}
// - length: {"min": 5, "max": 255}
// - format: {"type": "email"} или {"type": "url"}
type ValidatorDefinition struct {
	Name        string                 `json:"name"`                // Уникальное имя валидатора в рамках лексикона
	Description string                 `json:"description"`         // Человекочитаемое описание назначения и логики валидатора
	Fields      []string               `json:"fields"`              // Список полей для валидации (пустой = валидация всей записи)
	Type        ValidatorType          `json:"type"`                // Тип валидации (определяет алгоритм проверки)
	Config      map[string]interface{} `json:"config,omitempty"`    // Параметры конфигурации валидатора (зависят от типа)
	ErrorMsg    string                 `json:"error_msg,omitempty"` // Кастомное сообщение об ошибке для UI
}

// ValidatorType определяет тип и алгоритм валидации данных
//
// ВЫБОР ТИПА ВАЛИДАТОРА:
// Правильный выбор типа обеспечивает баланс между безопасностью данных
// и производительностью валидации. Валидаторы выполняются в порядке
// определения в лексиконе.
//
// ПРОИЗВОДИТЕЛЬНОСТЬ ПО ТИПАМ:
// - required: мгновенная проверка присутствия поля
// - regex: зависит от сложности регулярного выражения
// - range: быстрая числовая проверка
// - length: O(1) для строк, O(n) для массивов
// - format: встроенные форматы оптимизированы
// - custom: производительность зависит от реализации
//
// СОВМЕСТИМОСТЬ:
// Все типы валидаторов совместимы с IPLD схемами и работают
// на уровне десериализованных данных (после IPLD validation).
type ValidatorType string

const (
	ValidatorTypeRegex    ValidatorType = "regex"    // Валидация строкового поля по регулярному выражению
	ValidatorTypeRange    ValidatorType = "range"    // Проверка числового диапазона (min/max значения)
	ValidatorTypeLength   ValidatorType = "length"   // Проверка длины строки или размера массива/объекта
	ValidatorTypeFormat   ValidatorType = "format"   // Проверка предопределенных форматов (email, url, date, etc.)
	ValidatorTypeCustom   ValidatorType = "custom"   // Пользовательская функция валидации (RegisterValidator)
	ValidatorTypeRequired ValidatorType = "required" // Проверка обязательного присутствия поля (не null/empty)
)

// Migration определяет автоматическую миграцию данных между версиями лексикона
//
// НАЗНАЧЕНИЕ И ПРИНЦИПЫ:
// Миграции обеспечивают безопасную эволюцию схем данных с автоматическим
// преобразованием существующих записей при обновлении версии лексикона.
// Каждая миграция является атомарной операцией с возможностью отката.
//
// СТРАТЕГИИ МИГРАЦИИ:
// 1. Forward-only: только прямые миграции (рекомендуется для prod)
// 2. Bidirectional: поддержка отката (для dev/staging окружений)
// 3. Data-preserving: сохранение всех данных с трансформацией
// 4. Breaking changes: создание новой версии с manual migration
//
// ТИПЫ ПРЕОБРАЗОВАНИЙ:
// - Структурные: добавление/удаление/переименование полей схемы
// - Типовые: изменение типов данных с автоматическим приведением
// - Индексные: обновление индексов в соответствии с новой схемой
// - Валидационные: обновление правил валидации без потери данных
//
// БЕЗОПАСНОСТЬ:
// - Автоматический backup перед миграцией
// - Transactional execution с rollback при ошибках
// - Dry-run режим для тестирования миграций
// - Validation existing data против новой схемы
//
// ПРОИЗВОДИТЕЛЬНОСТЬ:
// Миграции выполняются в фоне с прогрессом и возможностью паузы.
// Большие миграции автоматически разбиваются на батчи.
//
// ПРИМЕРЫ МЕТАДАННЫХ:
// add_field: {"field_name": "tags", "default_value": [], "position": "after:title"}
// change_type: {"field": "price", "from": "string", "to": "number", "converter": "parseFloat"}
// custom: {"script_lang": "lua", "batch_size": 1000, "timeout": "5m"}
type Migration struct {
	FromVersion SchemaVersion          `json:"from_version"`       // Исходная версия схемы (источник миграции)
	ToVersion   SchemaVersion          `json:"to_version"`         // Целевая версия схемы (результат миграции)
	Type        MigrationType          `json:"type"`               // Тип операции миграции (определяет алгоритм)
	Script      string                 `json:"script"`             // Скрипт/код для custom миграций (Lua, SQL, или Go)
	Metadata    map[string]interface{} `json:"metadata,omitempty"` // Параметры миграции (зависят от типа)
	CreatedAt   time.Time              `json:"created_at"`         // Временная метка создания миграции
}

// MigrationType определяет тип операции миграции схемы
//
// КАТЕГОРИИ МИГРАЦИЙ:
// 1. Аддитивные (add_field) - безопасные, обратно совместимые
// 2. Деструктивные (remove_field) - требуют осторожности, могут ломать compatibility
// 3. Трансформирующие (change_type, rename_field) - требуют преобразования данных
// 4. Пользовательские (custom) - полный контроль с ручной реализацией
//
// ПЛАНИРОВАНИЕ МИГРАЦИЙ:
// MigrationManager автоматически строит граф зависимостей и определяет
// оптимальный порядок выполнения для сложных цепочек миграций.
//
// СОВМЕСТИМОСТЬ:
// - add_field: обратно совместимо (старые клиенты игнорируют новые поля)
// - remove_field: ломает compatibility (требует обновления всех клиентов)
// - rename_field: условно совместимо (можно реализовать алиасы)
// - change_type: зависит от типов (string->number может ломать парсинг)
type MigrationType string

const (
	MigrationTypeAddField    MigrationType = "add_field"    // Добавление нового поля в схему (backward compatible)
	MigrationTypeRemoveField MigrationType = "remove_field" // Удаление существующего поля (breaking change)
	MigrationTypeRenameField MigrationType = "rename_field" // Переименование поля с сохранением типа и данных
	MigrationTypeChangeType  MigrationType = "change_type"  // Изменение типа поля с автоматическим приведением
	MigrationTypeCustom      MigrationType = "custom"       // Произвольная пользовательская миграция через скрипт
)
